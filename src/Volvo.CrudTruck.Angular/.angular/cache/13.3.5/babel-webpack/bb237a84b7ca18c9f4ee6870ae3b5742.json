{"ast":null,"code":"/**\r\n * Simple logger system with the possibility of registering custom outputs.\r\n *\r\n * 4 different log levels are provided, with corresponding methods:\r\n * - debug   : for debug information\r\n * - info    : for informative status of the application (success, ...)\r\n * - warning : for non-critical errors that do not prevent normal application behavior\r\n * - error   : for critical errors that prevent normal application behavior\r\n *\r\n * Example usage:\r\n * ```\r\n * import { Logger } from 'app/core/logger.service';\r\n *\r\n * const log = new Logger('myFile');\r\n * ...\r\n * log.debug('something happened');\r\n * ```\r\n *\r\n * To disable debug and info logs in production, add this snippet to your root component:\r\n * ```\r\n * export class AppComponent implements OnInit {\r\n *   ngOnInit() {\r\n *     if (environment.production) {\r\n *       Logger.enableProductionMode();\r\n *     }\r\n *     ...\r\n *   }\r\n * }\r\n *\r\n * If you want to process logs through other outputs than console, you can add LogOutput functions to Logger.outputs.\r\n */\n\n/**\r\n * The possible log levels.\r\n * LogLevel.Off is never emitted and only used with Logger.level property to disable logs.\r\n */\nexport var LogLevel = /*#__PURE__*/(() => {\n  (function (LogLevel) {\n    LogLevel[LogLevel[\"Off\"] = 0] = \"Off\";\n    LogLevel[LogLevel[\"Error\"] = 1] = \"Error\";\n    LogLevel[LogLevel[\"Warning\"] = 2] = \"Warning\";\n    LogLevel[LogLevel[\"Info\"] = 3] = \"Info\";\n    LogLevel[LogLevel[\"Debug\"] = 4] = \"Debug\";\n  })(LogLevel || (LogLevel = {}));\n\n  return LogLevel;\n})();\nexport class Logger {\n  constructor(source) {\n    this.source = source;\n  }\n  /**\r\n   * Enables production mode.\r\n   * Sets logging level to LogLevel.Warning.\r\n   */\n\n\n  static enableProductionMode() {\n    Logger.level = LogLevel.Warning;\n  }\n  /**\r\n   * Logs messages or objects  with the debug level.\r\n   * Works the same as console.log().\r\n   */\n\n\n  debug(...objects) {\n    this.log(console.log, LogLevel.Debug, objects);\n  }\n  /**\r\n   * Logs messages or objects  with the info level.\r\n   * Works the same as console.log().\r\n   */\n\n\n  info(...objects) {\n    this.log(console.info, LogLevel.Info, objects);\n  }\n  /**\r\n   * Logs messages or objects  with the warning level.\r\n   * Works the same as console.log().\r\n   */\n\n\n  warn(...objects) {\n    this.log(console.warn, LogLevel.Warning, objects);\n  }\n  /**\r\n   * Logs messages or objects  with the error level.\r\n   * Works the same as console.log().\r\n   */\n\n\n  error(...objects) {\n    this.log(console.error, LogLevel.Error, objects);\n  }\n\n  log(func, level, objects) {\n    if (level <= Logger.level) {\n      const log = this.source ? ['[' + this.source + ']'].concat(objects) : objects;\n      func.apply(console, log);\n      Logger.outputs.forEach(output => output.apply(output, [this.source, level, ...objects]));\n    }\n  }\n\n}\n/**\r\n * Current logging level.\r\n * Set it to LogLevel.Off to disable logs completely.\r\n */\n\nLogger.level = LogLevel.Debug;\n/**\r\n * Additional log outputs.\r\n */\n\nLogger.outputs = [];","map":null,"metadata":{},"sourceType":"module"}