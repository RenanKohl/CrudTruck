{"ast":null,"code":"import { RouteReuseStrategy } from '@angular/router';\nimport * as i0 from \"@angular/core\";\n/**\r\n * A route strategy allowing for explicit route reuse.\r\n * Used as a workaround for https://github.com/angular/angular/issues/18374\r\n * To reuse a given route, add `data: { reuse: true }` to the route definition.\r\n */\n\nexport let RouteReusableStrategy = /*#__PURE__*/(() => {\n  class RouteReusableStrategy extends RouteReuseStrategy {\n    shouldDetach(route) {\n      return false;\n    }\n\n    store(route, detachedTree) {}\n\n    shouldAttach(route) {\n      return false;\n    }\n\n    retrieve(route) {\n      return null;\n    }\n\n    shouldReuseRoute(future, curr) {\n      var _a, _b, _c; // Reuse the route if the RouteConfig is the same, or if both routes use the\n      // same component, because the latter can have different RouteConfigs.\n\n\n      return future.routeConfig === curr.routeConfig || Boolean(((_a = future.routeConfig) === null || _a === void 0 ? void 0 : _a.component) && ((_b = future.routeConfig) === null || _b === void 0 ? void 0 : _b.component) === ((_c = curr.routeConfig) === null || _c === void 0 ? void 0 : _c.component));\n    }\n\n  }\n\n  RouteReusableStrategy.ɵfac = /*@__PURE__*/function () {\n    let ɵRouteReusableStrategy_BaseFactory;\n    return function RouteReusableStrategy_Factory(t) {\n      return (ɵRouteReusableStrategy_BaseFactory || (ɵRouteReusableStrategy_BaseFactory = i0.ɵɵgetInheritedFactory(RouteReusableStrategy)))(t || RouteReusableStrategy);\n    };\n  }();\n\n  RouteReusableStrategy.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: RouteReusableStrategy,\n    factory: RouteReusableStrategy.ɵfac\n  });\n  return RouteReusableStrategy;\n})();","map":null,"metadata":{},"sourceType":"module"}